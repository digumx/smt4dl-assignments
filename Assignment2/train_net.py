"""
Script to train a network using data generated by datagen and using tensorflow.keras

Command line arguments:
    Arg 1:  Size of data to generate, defaults to 10000, must eval to int
    Arg 2:  Number of epochs to train, defaults to 300, must eval to int
    Arg 3:  Ratio of training vs testing data, defaults to 0.6, must eval to float
"""

import sys

from tensorflow.keras import models, layers, losses
import z3

from datagen import *
from encode_dnn import *
from game_props import *


"""
Parse command line args
"""

if len(sys.argv) >= 2:
    num = eval(sys.argv[1])
else:
    num = 10000
if len(sys.argv) >= 3:
    epch = eval(sys.argv[2])
else:
    epch = 300
if len(sys.argv) >= 4:
    ratio = eval(sys.argv[3])
else:
    ratio = 0.6


"""
Generate Data
"""

data = gen_data(num)


"""
Make and train DNN
"""

# Create a simple DNN model
dnn = models.Sequential([
        layers.Input(shape = (36,)),
        layers.Dense(20, activation='relu'),
        layers.Dense(10, activation='relu'),
        layers.Dense(2, activation='relu'),])

# We do not use the softmax normalization in the DNN itself. Instead, we bake a normalization into
# the loss function by using the BinaryCrossentropy function with the from_logits flag set to True.
# This will effectively apply softmax while calculating loss, but the model itself does not apply
# softmax to the output.
dnn.compile(loss = losses.BinaryCrossentropy(from_logits = True), metrics = ['accuracy'])

# Split training and testing data, prepare data
train_x = list(map(lambda x : [1 if c else 0 for c in x], [p[0] for p in data[:int(ratio*num)]]))
train_y = [([0, 1] if p[1] else [1, 0]) for p in data[:int(ratio*num)]]
test_x = list(map(lambda x : [1 if c else 0 for c in x], [p[0] for p in data[int(ratio*num):]]))
test_y = [([0, 1] if p[1] else [1, 0]) for p in data[int(ratio*num):]]

# Train model
dnn.fit(train_x, train_y, epochs=epch)

# Test model
dnn.evaluate(test_x, test_y, verbose=2)

# Get weights
#print([(type(l.get_weights()), l.get_weights()) for l in dnn.layers])



"""
Verify properties
"""

# We first create a solver and constants
solver = z3.Solver()
z3_move =   [z3.Const("move_"+str(i), z3.BoolSort()) for i in range(36)]        # Move
z3_res =    [z3.Const("res_"+str(i), z3.BoolSort()) for i in range(27)]         # Result of move
z3_inp =    [z3.Const("inp_"+str(i), z3.RealSort()) for i in range(36)]         # Input to nn

# We get the weights and biases of the network
weights = [l.get_weights()[0].tolist() for l in dnn.layers]
biases =  [l.get_weights()[1].tolist() for l in dnn.layers]


# For Q3

# We assert that z3_move is valid
assert_valid_move(solver, z3_move)
# z3_res is the result of doing the move
solver.add(encode_move(z3_move[:27], z3_res, z3_move[27:], 1))
# z3_inp encodes input for nn
assert_input_encoding(solver, z3_move, z3_inp)
# The expression encoding the output of the network
z3_out = encode_network(weights, biases, z3_inp)

# Assert that the network classifies output as good
solver.add(z3_out[1] > z3_out[0])
# But player 2 can win from resulting config
solver.add(encode_has_winning_move(z3_move[:27], 2))

# Check sat and print cex
res = solver.check()
check_result = res == z3.sat
print("Check for Q3: " + ("Failed" if check_result else "Passed"))
if check_result:
    mdl = solver.model()
    for i in range(3):
        print([(0 if mdl.eval(z3_move[9*i + 3*j + 0]) else
                1 if mdl.eval(z3_move[9*i + 3*j + 1]) else 2) for j in range(3)])
    for v,i in zip(z3_move[27:], range(9)):
        if mdl.eval(v):
            print("Move ", i)

# For Q4


# All the above constraints must still be maintained. We additionally require that the input has a
# player 1 mark at the center and at one of the corners.
solver.add(z3.And(z3_move[4*3 + 1], z3.Or(z3_move[1], z3_move[2*3 + 1], z3_move[6*3 + 1],
                                            z3_move[8*3 + 1])))
res = solver.check()
check_result = res == z3.sat
print("Check for Q3: " + ("Failed" if check_result else "Passed"))
if check_result:
    mdl = solver.model()
    for i in range(3):
        print([(0 if mdl.eval(z3_move[9*i + 3*j + 0]) else
                1 if mdl.eval(z3_move[9*i + 3*j + 1]) else 2) for j in range(3)])
    for v,i in zip(z3_move[27:], range(9)):
        if mdl.eval(v):
            print("Move ", i)

